# Микрокр 6

|    | 24680                                                                               | 13579                                                                                              |
|----|-------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|
| 1. | В чём разница между виртуальными машинами в платформах Java SE и Java / Jakarta EE? | В чём разница между веб-сервером и сервером приложений?                                            |
| 2. | Каким образом и с какой целью в JEE используется протокол JNDI?                     | Зачем и каким образом в JEE реализуется принцип Location Transparency?                             |
| 3. | JSF Managed или CDI Bean, реализующий логику управления шлагбаумом.                 | JSF Managed или CDI Bean, реализующий логику калькулятор с одной операцией - сложение целых чисел. |

## Варианты `24680`

### **1. В чём разница между виртуальными машинами в платформах Java SE и Java / Jakarta EE?**

Фактически, виртуальная машина на этих платформах - одна и та же. Как в Java SE, так и в Jakarta EE используется стандартная `JVM` для выполнения Java-приложений.

- Разница лишь в том, что jakarta EE включает в себя *дополнительные компоненты и сервисы*, необходимые для корпоративных приложений(веб-контейнеры как Wildfly, TomCat)(компоненты как EJB, сервлеты, постлеты, jsp)(JMS, RMI, JPA и прочие мощные инструменты для энтерпрайза).

- Если рассмотреть жизненный цикл сервлёта, к примеру, сначала сервлёты компилируются в классы обычной `Java SE JVM` в `.class`, затем эти классы сервлётов загружаются в веб-контейнер, который управляет жизненным циклом сервлетов, начиная от их инициализации (`init()`), обработки запросов (`service()`) и завершения работы (`destroy()`).

- В Java SE нет сервлётов, в ней приложения управляются напрямую JVM. В GUI-приложениях, логика управления пользовательским интерфейсом и событиями обрабатывается через библиотеки, такие как Swing или JavaFX.

- Выше я наглядно продемонстрировал, что в java ee используется та же JVM, что и в java se, отличие лишь в том, что `java ee` имеет более широкую инфраструктуру, используя контейнеры с веб-контейнером сервлётов и прочие службы для управления транзакциями, распределёнными вычислениями и т.д.

### **2. Каким образом и с какой целью в JEE используется протокол JNDI?**

NDI (Java Naming and Directory Interface) используется в Java EE для поиска и связывания ресурсов и сервисов в контексте приложения. Он действует как каталог или служба именования, позволяя компонентам приложения находить друг друга и взаимодействовать

1) работа с DS:
необходимо объявить ресурс в конфигурационном файле сервера приложений или в файле web.xml вашего приложения, а потом можно

```java
DataSource ds = (DataSource) ctx.lookup("java:cmp/env/jdbc/DS");
```

2) поиск EJB:
объявлям EJB и ищем:

```java
Bean bean = (Bean) ctx.lookup("java:cmp/env/Bean");
```

3) пиздим конфигурацию из конфигурационного объекта:

```java
String someCfgValue = (String) ctx.lookup("java:comp/env/myCfgValue");
```

### **3. JSF Managed или CDI Bean, реализующий логику управления шлагбаумом.**

- **BarrierControlBean.java**:

```java
@Named
@RequestScoped
@Data // import lombok.Data; для POJO
public class BarrierControlBean implements Serializable {
    private static final long serialVersionUID = 1L;

    private boolean isOpen = false;

    public void openBarrier() {
        isOpen = true;
        // аткрываем шлакбаум!
    }

    public void closeBarrier() {
        isOpen = false;
        // закрываем шлакбаум!
    }
}
```

- **barrier.xhtml**:

```html
<h:head>
    <title>Управление Шлагбаумом</title>
</h:head>
<h:body>
    <h:form>
        <h:commandButton value="Открыть шлагбаум" 
                         action="#{barrierControlBean.openBarrier}" 
                         rendered="#{!barrierControlBean.open}"/>
        <h:commandButton value="Закрыть шлагбаум" 
                         action="#{barrierControlBean.closeBarrier}" 
                         rendered="#{barrierControlBean.open}"/>
    </h:form>
    <h:outputText value="Статус: шлагбаум "/>
    <h:outputText value="#{barrierControlBean.open ? 'открыт' : 'закрыт'}"/>
</h:body>
```

## Варианты `13579`

### **1. В чём разница между веб-сервером и сервером приложений?**

#### Веб-сервер

- обрабатывает http-запросы, отсылает статический html, css, js, вместе с ресурсами(картинки, e.t.c.)
- К примеру, на гелиосе у нас Nginx, и когда мы 1 лабу сдавали - она работала с помощью него
- `Nginx`, `Apache HTTP Server`, `Microsoft IIS`

#### Сервер приложений (application server)

- Расширяет возможности веб-сервера с помощью поддержки динамической генерации контента, логики приложения и интеграции с различными ресурсами
- Предоставляет runtime environment, в котором исполняется приложение и взаимодействует с базой данных и прочими компонентами
- использует бизнес-логику, чтобы обмениваться данными более логично, чем веб-сервер
- `Wildfly`, `Tomcat`, `Glassfish`

### **2. Зачем и каким образом в JEE реализуется принцип Location Transparency?**

- чтобы система функционировала независимо от расположения компонентов и ресурсов
- через JNDI(RMI) - находим ресурсы и компоненты,
- EJB - вызываем по RMI удалённые бины,
- JTA - транзакции могут распространяться на многочисленные сервера

### **3. JSF Managed или CDI Bean, реализующий логику калькулятор с одной операцией - сложение целых чисел.**

```java
@Named
@RequestScoped 
@Data
public class CalculatorBean implements Serializable {
    private static final long serialVersionUID = 1L;

    public double sum(double a, double b) {
        return a + b;
    }
}
```

# Микрокр 5

|    | 13579                                                                                                          | 24680                                                                                                            |
|----|----------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|
| 1. | Чем `@CustomScoped` бины отличаются от `@ViewScoped`?                                                          | Чем `@NoneScoped` бины отличаются от `@ApplicationScoped`?                                                       |
| 2. | Чем конструкция `${bean.property}` отличается от конструкции `#{bean.property}`?                               | Какой из этих фрагментов кода не скомпилируется, и почему? <br> (1) `#{bean.action}` <br> (2) `#{bean.action()}` |
| 3. | Код управляемого бина, содержащего метод, возвращающий время с момента рестарта сервера или деплоя приложения. | Код JSF-страницы, показывающей значение параметра `user-name` из HTTP-запроса.                                   |

## Варианты `13579`

### **1. Чем `@CustomScoped` бины отличаются от `@ViewScoped`?**

### @ViewScoped - экземпляр создаётся один раз при обращении к странице, и используется ровно столько, сколько пользователь находится на странице:

1. **Жизненный Цикл**: Существует в течение одного представления (view) JSF.
2. **Использование**: Часто используется для AJAX-взаимодействий в рамках одной страницы.
3. **Особенности**: Уничтожается при переходе на новую страницу.

### @CustomScoped - экземпляр создаётся и сохраняется в Map. Программист сам управляет областью жизни:

1. **Жизненный Цикл**: Пользовательский; определяется через `Map`.
2. **Использование**: Для специфических требований, не покрываемых стандартными скоупами.
3. **Особенности**: Гибкость в определении жизненного цикла.

> В `@CustomScoped`, вы должны предоставить `Map объект`, который определяет характеристики области видимости. Это может включать в себя время жизни, механизмы хранения и другие параметры. Этот Map служит для управления жизненным циклом бина.

### **2. Чем конструкция `${bean.property}` отличается от конструкции `#{bean.property}`?**

В Expression Language (EL) существуют два типа выражений: `${}` (Immediate) и `#{}` (Deferred).

1. **`${bean.property}` (Immediate)**
    - **Жизненный Цикл**: Вычисляется немедленно на этапе обработки страницы (срабатывают, как только разворачивается представление в 1ой фазе ЖЦ).
    - **Ограничения**: Только чтения, а не для записи данных, не может быть использовано для привязки к компонентам, требующим двустороннего взаимодействия.

2. **`#{bean.property}` (Deferred)**
    - **Жизненный Цикл**: Вычисляются в определенный момент жизненного цикла JSF, который может быть управляем. Это может происходить, например, при событиях валидации, обновления модели и так далее.
    - **Особенности**: Поддерживает как чтение, так и запись. Используется для привязки компонентов к бинам.

`${}` используется для односторонних операций, в основном чтения, тогда как `#{}` используется для двустороннего взаимодействия и поддерживает больше функциональности.

### **3. Код управляемого бина, содержащего метод, возвращающий время с момента рестарта сервера или деплоя приложения.**

```java
@ApplicationScoped
public class ServerStartTimeBean {

    private LocalDateTime startTime;

    @PostConstruct
    public void init() {
        startTime = LocalDateTime.now();
    }

    public String getTimeSinceRestart() {
        long totalSeconds = Duration.between(startTime, LocalDateTime.now()).getSeconds();

        long hours = totalSeconds / 3600;
        long minutes = (totalSeconds % 3600) / 60;
        long seconds = totalSeconds % 60;

        return String.format("%d hours, %d minutes, %d seconds", hours, minutes, seconds);
    }
}
```

## Варианты `24680`

### **1. Чем `@NoneScoped` бины отличаются от `@ApplicationScoped`?**

#### Кратко:

- **Область действия**:
  - `@NoneScoped`: Не имеет конкретного скоупа; каждое обращение к бину создает новый экземпляр бина.
  - `@ApplicationScoped`: Есть один экземпляр на все время жизни приложения; общий для всех пользователей и сессий.

- **Длительность жизни**:
  - `@NoneScoped`: Краткосрочная; живет только во время одного вызова.
  - `@ApplicationScoped`: Долгосрочная; живет на протяжении всего времени жизни приложения.

#### Подробно:

- `@NoneScoped`: Бины с этой аннотацией не находятся в каком-либо определенном скоупе. Это означает, что каждый раз, когда к бину осуществляется обращение, создается новый экземпляр. Бины с аннотацией @NoneScoped обычно используются в качестве базовых классов для других бинов или когда бин не требует сохранения состояния между запросами.
- `@ApplicationScoped`: Бин с этой аннотацией создается один раз на всё время жизни приложения. Это означает, что все пользователи и все сессии используют один и тот же экземпляр этого бина. Он идеален для хранения данных, которые общие для всех пользователей и сессий.

### **2. Какой из этих фрагментов кода не скомпилируется, и почему?**

Оба фрагмента кода являются синтаксически корректными выражениями Expression Language (EL) и могут быть использованы в страницах JSF. Однако их поведение будет разным:

1. `#{bean.action}`: Это выражение будет пытаться получить значение свойства или метода `action` в `bean`. Если такого свойства или метода нет, будет выброшена ошибка **во время выполнения**, но не во время компиляции.

2. `#{bean.action()}`: Это выражение будет пытаться вызвать метод `action()` в `bean`. Если такого метода нет, будет выброшена ошибка **во время выполнения**.

Оба эти фрагмента **не вызывают ошибок компиляции**, потому что они обрабатываются во время выполнения, и JSF/EL отложенно проверяют наличие соответствующих методов или свойств.

#### Пример рабочего кода для `bean`:

```java
@ManagedBean
public class Bean {
    // для #{bean.action}
    public String getAction() {
        return "actionValue";
    }

    // для #{bean.action()}
    public String action() {
        return "actionMethodValue";
    }
}
```

### **3. Код JSF-страницы, показывающей значение параметра `user-name` из HTTP-запроса.**

```java
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html">
<h:head>
    <title>Отображение параметра запроса</title>
</h:head>
<h:body>
  <h:outputText value="User Name: " />
  <h:outputText value="#{param['user-name']}" />
</h:body>
</html>
```